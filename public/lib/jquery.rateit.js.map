{"version":3,"sources":["webpack:///webpack/bootstrap","webpack:///./lib/bundles/jquery.rateit.js","webpack:///./node_modules/jquery.rateit/scripts/jquery.rateit.js","webpack:///./node_modules/jquery.rateit/scripts/rateit.css?ba63"],"names":[],"mappings":";QAAA;QACA;;QAEA;QACA;;QAEA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;;QAEA;QACA;;QAEA;QACA;;QAEA;QACA;QACA;;;QAGA;QACA;;QAEA;QACA;;QAEA;QACA;QACA;QACA,0CAA0C,gCAAgC;QAC1E;QACA;;QAEA;QACA;QACA;QACA,wDAAwD,kBAAkB;QAC1E;QACA,iDAAiD,cAAc;QAC/D;;QAEA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA,yCAAyC,iCAAiC;QAC1E,gHAAgH,mBAAmB,EAAE;QACrI;QACA;;QAEA;QACA;QACA;QACA,2BAA2B,0BAA0B,EAAE;QACvD,iCAAiC,eAAe;QAChD;QACA;QACA;;QAEA;QACA,sDAAsD,+DAA+D;;QAErH;QACA;;;QAGA;QACA;;;;;;;;AClFA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB;AACzB;AACA,gCAAgC;AAChC;AACA;AACA;AACA,4BAA4B;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,mBAAO,CAAC,GAAe;AACvB,mBAAO,CAAC,GAAkC;;;;;;;;ACjC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,yBAAyB;AACzB;AACA;AACA;;AAEA,gCAAgC,aAAa;;;AAG7C;AACA;AACA,iCAAiC,4BAA4B;AAC7D;AACA;AACA,mEAAmE;AACnE;AACA;AACA;AACA;;AAEA;AACA;;;AAGA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA,wDAAwD;AACxD;;AAEA;AACA;AACA,6CAA6C;AAC7C;AACA;AACA;;AAEA,6CAA6C;AAC7C;AACA,8HAA8H;AAC9H;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qCAAqC,8BAA8B;AACnE,qCAAqC,8BAA8B;AACnE,sCAAsC,gCAAgC;AACtE;AACA;AACA;;AAEA;AACA,2CAA2C,yBAAyB;;AAEpE;;AAEA;AACA;AACA,wCAAwC,sCAAsC;;;AAG9E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+HAA+H;AAC/H;AACA,4CAA4C,+BAA+B;AAC3E;AACA;AACA,4CAA4C,aAAa;AACzD;AACA,oDAAoD,iBAAiB;AACrE,oDAAoD;AACpD,sDAAsD,kBAAkB;AACxE;;AAEA;AACA;;;AAGA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,mDAAmD;AACnD;;AAEA;AACA,8EAA8E;;AAE9E,0FAA0F;AAC1F;AACA;AACA;AACA;AACA;AACA,gIAAgI;AAChI;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sIAAsI;AACtI;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;;;;AAIA;AACA;AACA;;AAEA;AACA,uDAAuD,OAAO,kIAAkI,OAAO,2BAA2B,SAAS,oBAAoB,OAAO,2KAA2K,OAAO,+HAA+H,SAAS,0BAA0B,SAAS,IAAI,SAAS,6BAA6B,SAAS,IAAI,SAAS,0BAA0B,SAAS,KAAK,SAAS;AACptB,4CAA4C,OAAO,uBAAuB,SAAS;;AAEnF;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA,0EAA0E;AAC1E;;AAEA;;;;;AAKA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;;AAEA;AACA,8BAA8B,UAAU;AACxC;AACA;;AAEA;;;AAGA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,iBAAiB;;AAEjB;;AAEA;AACA;AACA;;AAEA;AACA,2BAA2B;AAC3B,8CAA8C,yBAAyB;AACvE,kCAAkC,aAAa;;AAE/C;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,+HAA+H;AAC/H;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2CAA2C;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,mEAAmE;AACnE;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;;AAErB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;;AAErB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,SAAS;AACT;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,iDAAiD;AACjD,8CAA8C;AAC9C;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,4BAA4B;;AAE5B;AACA,mBAAmB,uCAAuC,EAAE;;AAE5D,CAAC;;;;;;;;AC5ZD,uC","file":"jquery.rateit.js","sourcesContent":[" \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 511);\n","/**\n * ---------------------------------------------------------------------\n * GLPI - Gestionnaire Libre de Parc Informatique\n * Copyright (C) 2015-2021 Teclib' and contributors.\n *\n * http://glpi-project.org\n *\n * based on GLPI - Gestionnaire Libre de Parc Informatique\n * Copyright (C) 2003-2014 by the INDEPNET Development Team.\n *\n * ---------------------------------------------------------------------\n *\n * LICENSE\n *\n * This file is part of GLPI.\n *\n * GLPI is free software; you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation; either version 2 of the License, or\n * (at your option) any later version.\n *\n * GLPI is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with GLPI. If not, see <http://www.gnu.org/licenses/>.\n * ---------------------------------------------------------------------\n */\n\n// RateIt jQuery plugin\nrequire('jquery.rateit');\nrequire('jquery.rateit/scripts/rateit.css');\n","﻿/*! RateIt | v1.1.2 / 03/28/2019\r\n    https://github.com/gjunge/rateit.js | Twitter: @gjunge\r\n*/\r\n(function ($) {\r\n    $.rateit = {\r\n        aria: {\r\n            resetLabel: 'reset rating',\r\n            ratingLabel: 'rating'\r\n        }\r\n    };\r\n\r\n    $.fn.rateit = function (p1, p2) {\r\n        //quick way out.\r\n        var index = 1;\r\n        var options = {}; var mode = 'init';\r\n        var capitaliseFirstLetter = function (string) {\r\n            return string.charAt(0).toUpperCase() + string.substr(1);\r\n        };\r\n\r\n        if (this.length === 0) { return this; }\r\n\r\n\r\n        var tp1 = $.type(p1);\r\n        if (tp1 == 'object' || p1 === undefined || p1 === null) {\r\n            options = $.extend({}, $.fn.rateit.defaults, p1); //wants to init new rateit plugin(s).\r\n        }\r\n        else if (tp1 == 'string' && p1 !== 'reset' && p2 === undefined) {\r\n            return this.data('rateit' + capitaliseFirstLetter(p1)); //wants to get a value.\r\n        }\r\n        else if (tp1 == 'string') {\r\n            mode = 'setvalue';\r\n        }\r\n\r\n        return this.each(function () {\r\n            var item = $(this);\r\n\r\n\r\n            //shorten all the item.data('rateit-XXX'), will save space in closure compiler, will be like item.data('XXX') will become x('XXX')\r\n            var itemdata = function (key, value) {\r\n\r\n                if (value != null) {\r\n                    //update aria values\r\n                    var ariakey = 'aria-value' + ((key == 'value') ? 'now' : key);\r\n                    var range = item.find('.rateit-range');\r\n                    if (range.attr(ariakey) != undefined) {\r\n                        range.attr(ariakey, value);\r\n                    }\r\n\r\n                }\r\n\r\n                arguments[0] = 'rateit' + capitaliseFirstLetter(key);\r\n                return item.data.apply(item, arguments); ////Fix for WI: 523\r\n            };\r\n\r\n            //handle programmatic reset\r\n            if (p1 == 'reset') {\r\n                var setup = itemdata('init'); //get initial value\r\n                for (var prop in setup) {\r\n                    item.data(prop, setup[prop]);\r\n                }\r\n\r\n                if (itemdata('backingfld')) { //reset also backingfield\r\n                    var fld = $(itemdata('backingfld'));\r\n                    // If backing field is a select box with valuesrc option set to \"index\", reset its selectedIndex property; otherwise, reset its value.\r\n                    if (fld[0].nodeName == 'SELECT' && fld[0].getAttribute('data-rateit-valuesrc') === 'index') {\r\n                        fld.prop('selectedIndex', itemdata('value'));\r\n                    }\r\n                    else {\r\n                        fld.val(itemdata('value'));\r\n                    }\r\n                    fld.trigger('change');\r\n                    if (fld[0].min) { fld[0].min = itemdata('min'); }\r\n                    if (fld[0].max) { fld[0].max = itemdata('max'); }\r\n                    if (fld[0].step) { fld[0].step = itemdata('step'); }\r\n                }\r\n                item.trigger('reset');\r\n            }\r\n\r\n            //add the rate it class.\r\n            if (!item.hasClass('rateit')) { item.addClass('rateit'); }\r\n\r\n            var ltr = item.css('direction') != 'rtl';\r\n\r\n            // set value mode\r\n            if (mode == 'setvalue') {\r\n                if (!itemdata('init')) { throw 'Can\\'t set value before init'; }\r\n\r\n\r\n                //if readonly now and it wasn't readonly, remove the eventhandlers.\r\n                if (p1 == 'readonly' && p2 == true && !itemdata('readonly')) {\r\n                    item.find('.rateit-range').unbind();\r\n                    itemdata('wired', false);\r\n                }\r\n                //when we receive a null value, reset the score to its min value.\r\n                if (p1 == 'value') {\r\n                    p2 = (p2 == null) ? itemdata('min') : Math.max(itemdata('min'), Math.min(itemdata('max'), p2));\r\n                }\r\n                if (itemdata('backingfld')) {\r\n                    //if we have a backing field, check which fields we should update. \r\n                    //In case of input[type=range], although we did read its attributes even in browsers that don't support it (using fld.attr())\r\n                    //we only update it in browser that support it (&& fld[0].min only works in supporting browsers), not only does it save us from checking if it is range input type, it also is unnecessary.\r\n                    var fld = $(itemdata('backingfld'));\r\n                    // If backing field is a select box with valuesrc option set to \"index\", update its selectedIndex property; otherwise, update its value.\r\n                    if (fld[0].nodeName == 'SELECT' && fld[0].getAttribute('data-rateit-valuesrc') === 'index') {\r\n                        if (p1 == 'value') { fld.prop('selectedIndex', p2); }\r\n                    }\r\n                    else {\r\n                        if (p1 == 'value') { fld.val(p2); }\r\n                    }\r\n                    if (p1 == 'min' && fld[0].min) { fld[0].min = p2; }\r\n                    if (p1 == 'max' && fld[0].max) { fld[0].max = p2;}\r\n                    if (p1 == 'step' && fld[0].step) { fld[0].step = p2; }\r\n                }\r\n\r\n                itemdata(p1, p2);\r\n            }\r\n\r\n\r\n            //init rateit plugin\r\n            if (!itemdata('init')) {\r\n\r\n                //get our values, either from the data-* html5 attribute or from the options.\r\n                itemdata('mode', itemdata('mode') || options.mode)\r\n                itemdata('icon', itemdata('icon') || options.icon)\r\n                itemdata('min', isNaN(itemdata('min')) ? options.min : itemdata('min'));\r\n                itemdata('max', isNaN(itemdata('max')) ? options.max : itemdata('max'));\r\n                itemdata('step', itemdata('step') || options.step);\r\n                itemdata('readonly', itemdata('readonly') !== undefined ? itemdata('readonly') : options.readonly);\r\n                itemdata('resetable', itemdata('resetable') !== undefined ? itemdata('resetable') : options.resetable);\r\n                itemdata('backingfld', itemdata('backingfld') || options.backingfld);\r\n                itemdata('starwidth', itemdata('starwidth') || options.starwidth);\r\n                itemdata('starheight', itemdata('starheight') || options.starheight);\r\n                itemdata('value', Math.max(itemdata('min'), Math.min(itemdata('max'), (!isNaN(itemdata('value')) ? itemdata('value') : (!isNaN(options.value) ? options.value : options.min)))));\r\n                itemdata('ispreset', itemdata('ispreset') !== undefined ? itemdata('ispreset') : options.ispreset);\r\n                //are we LTR or RTL?\r\n\r\n                if (itemdata('backingfld')) {\r\n                    //if we have a backing field, hide it, override defaults if range or select.\r\n                    var fld = $(itemdata('backingfld')).hide();\r\n\r\n                    if (fld.attr('disabled') || fld.attr('readonly')) {\r\n                        itemdata('readonly', true); //http://rateit.codeplex.com/discussions/362055 , if a backing field is disabled or readonly at instantiation, make rateit readonly.\r\n                    }\r\n\r\n                    if (fld[0].nodeName == 'INPUT') {\r\n                        if (fld[0].type == 'range' || fld[0].type == 'text') { //in browsers not support the range type, it defaults to text\r\n\r\n                            itemdata('min', parseInt(fld.attr('min')) || itemdata('min')); //if we would have done fld[0].min it wouldn't have worked in browsers not supporting the range type.\r\n                            itemdata('max', parseInt(fld.attr('max')) || itemdata('max'));\r\n                            itemdata('step', parseInt(fld.attr('step')) || itemdata('step'));\r\n                        }\r\n                    }\r\n                    if (fld[0].nodeName == 'SELECT' && fld[0].options.length > 1) {\r\n                        // If backing field is a select box with valuesrc option set to \"index\", use the indexes of its options; otherwise, use the values.\r\n                        if (fld[0].getAttribute('data-rateit-valuesrc') === 'index') {\r\n                            itemdata('min', (!isNaN(itemdata('min')) ? itemdata('min') : Number(fld[0].options[0].index)));\r\n                            itemdata('max', Number(fld[0].options[fld[0].length - 1].index));\r\n                            itemdata('step', Number(fld[0].options[1].index) - Number(fld[0].options[0].index));\r\n                        }\r\n                        else {\r\n                            itemdata('min', (!isNaN(itemdata('min')) ? itemdata('min') : Number(fld[0].options[0].value)));\r\n                            itemdata('max', Number(fld[0].options[fld[0].length - 1].value));\r\n                            itemdata('step', Number(fld[0].options[1].value) - Number(fld[0].options[0].value));\r\n                        }\r\n                        //see if we have a option that as explicity been selected\r\n                        var selectedOption = fld.find('option[selected]');\r\n                        if (selectedOption.length == 1) {\r\n                            // If backing field is a select box with valuesrc option set to \"index\", use the index of selected option; otherwise, use the value.\r\n                            if (fld[0].getAttribute('data-rateit-valuesrc') === 'index') {\r\n                                itemdata('value', selectedOption[0].index);\r\n                            }\r\n                            else {\r\n                                itemdata('value', selectedOption.val());\r\n                            }\r\n                        }\r\n                    }\r\n                    else {\r\n                        //if it is not a select box, we can get's it's value using the val function. \r\n                        //If it is a selectbox, we always get a value (the first one of the list), even if it was not explicity set.\r\n                        itemdata('value', fld.val());\r\n                    }\r\n\r\n                   \r\n                }\r\n\r\n              \r\n\r\n                //Create the necessary tags. For ARIA purposes we need to give the items an ID. So we use an internal index to create unique ids\r\n                var element = item[0].nodeName == 'DIV' ? 'div' : 'span';\r\n                index++;\r\n\r\n                // tabindex=\"0\" gets only added in readonly mode. When keyboard tabbing, no focus is needed in readonly mode.\r\n                var html = '<button id=\"rateit-reset-{{index}}\" type=\"button\" data-role=\"none\" class=\"rateit-reset\" aria-label=\"' + $.rateit.aria.resetLabel + '\" aria-controls=\"rateit-range-{{index}}\"><span></span></button><{{element}} id=\"rateit-range-{{index}}\" class=\"rateit-range\"' + (itemdata('readonly') == true ? '' : ' tabindex=\"0\"') + ' role=\"slider\" aria-label=\"' + $.rateit.aria.ratingLabel + '\" aria-owns=\"rateit-reset-{{index}}\" aria-valuemin=\"' + itemdata('min') + '\" aria-valuemax=\"' + itemdata('max') + '\" aria-valuenow=\"' + itemdata('value') + '\"><{{element}} class=\"rateit-empty\"></{{element}}><{{element}} class=\"rateit-selected\"></{{element}}><{{element}} class=\"rateit-hover\"></{{element}}></{{element}}>';\r\n                item.append(html.replace(/{{index}}/gi, index).replace(/{{element}}/gi, element));\r\n\r\n                //if we are in RTL mode, we have to change the float of the \"reset button\"\r\n                if (!ltr) {\r\n                    item.find('.rateit-reset').css('float', 'right');\r\n                    item.find('.rateit-selected').addClass('rateit-selected-rtl');\r\n                    item.find('.rateit-hover').addClass('rateit-hover-rtl');\r\n                }\r\n\r\n                if (itemdata('mode') == 'font') {\r\n                    item.addClass('rateit-font').removeClass('rateit-bg');\r\n                }\r\n                else {\r\n                    item.addClass('rateit-bg').removeClass('rateit-font');\r\n                }\r\n\r\n                itemdata('init', JSON.parse(JSON.stringify(item.data()))); //cheap way to create a clone\r\n            }\r\n\r\n            var isfont = itemdata('mode') == 'font';\r\n\r\n            \r\n\r\n\r\n            //resize the height of all elements, \r\n            if (!isfont) {\r\n                item.find('.rateit-selected, .rateit-hover').height(itemdata('starheight'));\r\n            }\r\n\r\n\r\n            var range = item.find('.rateit-range');\r\n            if (isfont) {\r\n                //fill the ranges with the icons\r\n                var icon = itemdata('icon');\r\n                var stars = itemdata('max') - itemdata('min');\r\n\r\n                var txt = '';\r\n                for(var i = 0; i< stars; i++){\r\n                    txt += icon;\r\n                }\r\n                \r\n                range.find('> *').text(txt);\r\n                \r\n\r\n                itemdata('starwidth', range.width() / (itemdata('max') - itemdata('min')))\r\n            }\r\n            else {\r\n                //set the range element to fit all the stars.\r\n                range.width(itemdata('starwidth') * (itemdata('max') - itemdata('min'))).height(itemdata('starheight'));\r\n            }\r\n\r\n\r\n            //add/remove the preset class\r\n            var presetclass = 'rateit-preset' + ((ltr) ? '' : '-rtl');\r\n            if (itemdata('ispreset')) {\r\n                item.find('.rateit-selected').addClass(presetclass);\r\n            }\r\n            else {\r\n                item.find('.rateit-selected').removeClass(presetclass);\r\n            }\r\n\r\n            //set the value if we have it.\r\n            if (itemdata('value') != null) {\r\n                var score = (itemdata('value') - itemdata('min')) * itemdata('starwidth');\r\n                item.find('.rateit-selected').width(score);\r\n            }\r\n\r\n            //setup the reset button\r\n            var resetbtn = item.find('.rateit-reset');\r\n            if (resetbtn.data('wired') !== true) {\r\n                resetbtn.bind('click', function (e) {\r\n                    e.preventDefault();\r\n\r\n                    resetbtn.blur();\r\n\r\n                    var event = $.Event('beforereset');\r\n                    item.trigger(event);\r\n                    if (event.isDefaultPrevented()) {\r\n                        return false;\r\n                    }\r\n\r\n                    item.rateit('value', null);\r\n                    item.trigger('reset');\r\n                }).data('wired', true);\r\n\r\n            }\r\n\r\n            //this function calculates the score based on the current position of the mouse.\r\n            var calcRawScore = function (element, event) {\r\n                var pageX = (event.changedTouches) ? event.changedTouches[0].pageX : event.pageX;\r\n\r\n                var offsetx = pageX - $(element).offset().left;\r\n                if (!ltr) { offsetx = range.width() - offsetx };\r\n                if (offsetx > range.width()) { offsetx = range.width(); }\r\n                if (offsetx < 0) { offsetx = 0; }\r\n\r\n                return score = Math.ceil(offsetx / itemdata('starwidth') * (1 / itemdata('step')));\r\n            };\r\n\r\n            //sets the hover element based on the score.\r\n            var setHover = function (score) {\r\n                var w = score * itemdata('starwidth') * itemdata('step');\r\n                var h = range.find('.rateit-hover');\r\n                if (h.data('width') != w) {\r\n                    range.find('.rateit-selected').hide();\r\n                    h.width(w).show().data('width', w);\r\n                    var data = [(score * itemdata('step')) + itemdata('min')];\r\n                    item.trigger('hover', data).trigger('over', data);\r\n                }\r\n            };\r\n\r\n            var setSelection = function (value) {\r\n                var event = $.Event('beforerated');\r\n                item.trigger(event, [value]);\r\n                if (event.isDefaultPrevented()) {\r\n                    return false;\r\n                }\r\n\r\n                itemdata('value', value);\r\n                if (itemdata('backingfld')) {\r\n                    // If backing field is a select box with valuesrc option set to \"index\", update its selectedIndex property; otherwise, update its value.\r\n                    if (fld[0].nodeName == 'SELECT' && fld[0].getAttribute('data-rateit-valuesrc') === 'index') {\r\n                        $(itemdata('backingfld')).prop('selectedIndex', value).trigger('change');\r\n                    }\r\n                    else {\r\n                        $(itemdata('backingfld')).val(value).trigger('change');\r\n                    }\r\n                }\r\n                if (itemdata('ispreset')) { //if it was a preset value, unset that.\r\n                    range.find('.rateit-selected').removeClass(presetclass);\r\n                    itemdata('ispreset', false);\r\n                }\r\n                range.find('.rateit-hover').hide();\r\n                range.find('.rateit-selected').width(value * itemdata('starwidth') - (itemdata('min') * itemdata('starwidth'))).show();\r\n                item.trigger('hover', [null]).trigger('over', [null]).trigger('rated', [value]);\r\n                return true;\r\n            };\r\n\r\n            if (!itemdata('readonly')) {\r\n                //if we are not read only, add all the events\r\n\r\n                //if we have a reset button, set the event handler.\r\n                if (!itemdata('resetable')) {\r\n                    resetbtn.hide();\r\n                }\r\n\r\n                //when the mouse goes over the range element, we set the \"hover\" stars.\r\n                if (!itemdata('wired')) {\r\n                    range.bind('touchmove touchend', touchHandler); //bind touch events\r\n                    range.mousemove(function (e) {\r\n                        var score = calcRawScore(this, e);\r\n                        setHover(score);\r\n                    });\r\n                    //when the mouse leaves the range, we have to hide the hover stars, and show the current value.\r\n                    range.mouseleave(function (e) {\r\n                        range.find('.rateit-hover').hide().width(0).data('width', '');\r\n                        item.trigger('hover', [null]).trigger('over', [null]);\r\n                        range.find('.rateit-selected').show();\r\n                    });\r\n                    //when we click on the range, we have to set the value, hide the hover.\r\n                    range.mouseup(function (e) {\r\n                        var score = calcRawScore(this, e);\r\n                        var value = (score * itemdata('step')) + itemdata('min');\r\n                        setSelection(value);\r\n                        range.blur();\r\n                    });\r\n\r\n                    //support key nav\r\n                    range.keyup(function (e) {\r\n                        if (e.which == 38 || e.which == (ltr ? 39 : 37)) {\r\n                            setSelection(Math.min(itemdata('value') + itemdata('step'), itemdata('max')));\r\n                        }\r\n                        if (e.which == 40 || e.which == (ltr ? 37 : 39)) {\r\n                            setSelection(Math.max(itemdata('value') - itemdata('step'), itemdata('min')));\r\n                        }\r\n                    });\r\n\r\n                    itemdata('wired', true);\r\n                }\r\n                if (itemdata('resetable')) {\r\n                    resetbtn.show();\r\n                }\r\n            }\r\n            else {\r\n                resetbtn.hide();\r\n            }\r\n\r\n            range.attr('aria-readonly', itemdata('readonly'));\r\n        });\r\n    };\r\n\r\n    //touch converter http://ross.posterous.com/2008/08/19/iphone-touch-events-in-javascript/\r\n    function touchHandler(event) {\r\n\r\n        var touches = event.originalEvent.changedTouches,\r\n                first = touches[0],\r\n                type = \"\";\r\n        switch (event.type) {\r\n            case \"touchmove\": type = \"mousemove\"; break;\r\n            case \"touchend\": type = \"mouseup\"; break;\r\n            default: return;\r\n        }\r\n\r\n        var simulatedEvent = document.createEvent(\"MouseEvent\");\r\n        simulatedEvent.initMouseEvent(type, true, true, window, 1,\r\n                              first.screenX, first.screenY,\r\n                              first.clientX, first.clientY, false,\r\n                              false, false, false, 0/*left*/, null);\r\n\r\n        first.target.dispatchEvent(simulatedEvent);\r\n        event.preventDefault();\r\n    };\r\n\r\n    //some default values.\r\n    $.fn.rateit.defaults = { min: 0, max: 5, step: 0.5, mode: 'bg', icon: '★', starwidth: 16, starheight: 16, readonly: false, resetable: true, ispreset: false };\r\n\r\n    //invoke it on all .rateit elements. This could be removed if not wanted.\r\n    $(function () { $('div.rateit, span.rateit').rateit(); });\r\n\r\n})(jQuery);\r\n","// extracted by mini-css-extract-plugin"],"sourceRoot":""}